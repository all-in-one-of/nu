%%% template.tex
%%%
%%% This LaTeX source document can be used as the basis for your technical
%%% paper or abstract. Regardless of the length of your document, the commands
%%% are all the same.
%%% 
%%% The "\documentclass" command is the first command in your file. If you want to ere
%%% prepare a version of your article with line numbers - a "review" version - 
%%% include the "review" parameter:
%%%    \documentclass[review]{acmsi_jggraph}
%%%

\documentclass{acmsiggraph}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{mathtools}
\usepackage{graphics}
\usepackage{float}

\newcommand{\Mod}[1]{\ (\text{mod}\ #1)}
\newcommand{\tab}{{\ \ \ \ }}
\newcommand{\Deg}{{^{\circ}}}
\newcommand{\detA}{det \textbf{A}}
\newcommand{\Iff}{\scalebox{0.7}[1]{$\iff$}}
\newcommand{\Imp}{\scalebox{0.6}[1]{$\implies$}}



%%% Title of your article or abstract.

\title{Virtual Bones: animating skinned meshes on GPU}

\author{Vladimir V. Lopatin\thanks{e-mail:vladimir.lopatin82@gmail.com}\\Senior VFX Artist, Guerrilla-Games}
\pdfauthor{Vladimir V. Lopatin}

%%% Used by the ``review'' variation; the online ID will be printed on 
%%% every page of the content.

\TOGonlineid{45678}

% User-generated keywords.

\keywords{GPU, crowd-rendering, shading, skinned meshes.}

%%% The next five lines define the rights management block on the first page.
%%% Replace them with the LaTeX commands provided when the form has been completed.

% \CopyrightYear{2016}
% \setcopyright{acmcopyright}
% \conferenceinfo{CONFERENCE PROGRAM NAME}{MONTH, DAY, and YEAR} 
% \isbn{THIS-IS-A-SAMPLE-ISBN}\acmPrice{\$15.00}
% \doi{http://doi.acm.org/THIS/IS/A/SAMPLE/DOI}

%%% Start of the document.

\begin{document}

%%% This is the ``teaser'' command, which puts an figure, centered, below 
%%% the title and author information, and above the body of the content.

 \teaser{
   \includegraphics[height=1.5in]{images/vda_teaser}
   \caption{A skinned mesh character, a virtual bones texture and multiple 3D impostors.}
 }

\maketitle

\begin{abstract}

  Thanks to recent advances in hardware development and mainstream adoption of  multicore GPU and CPU devices, software developers are able to tap into a pool of parallel computational resources.

%  At the same time as hardware is getting more computational threads, computer graphics standards in realtime applications are being pushed further: many things that have been, traditionally, a part of repertoir of non-realtime computer graphics,  are increasingly getting into real-time applications: modern audience often expects large quantities of high-quality characters and assets. That presents developers with new chalanges and opportunities.

  Traditionally, characters in CG applications are created as skinned meshes with CPU-driven skeletons and associated control-structures.  Due to computational constraints, running a large number of such characters on a CPU is cost-prohobitive and does not scale well.  When large numbers are needed, some form of impostor technique may be used, such as 2D sprites, which poses a different set of problems such as shading issues due to geometric discrapancy between original polygonal models and flat sprites, generating and storing sprite textures, etc.

  In this paper the authors are describing a shading algorithm that allows rendering animated 3D impostors (3D sprites), labeled here and further as `Virtual Bones`, developed by engineers at Guerrilla-Games during the production of open-world game `Horizon: Zero Dawn` (HZD) to cover the need to render a large number of animated assets in real-time, such as crowds and locations heavily decorated with animated cloth-like assets, taking advantage of modern multi-threaded hardware by reducing and offsetting computational costs from CPU to GPU.

  The paper is structured in the following way: \textbf{chapter 1} describes previous work and motivation, \textbf{chapter 2} describes implementation, \textbf{chapter 3} presents performance test results, \textbf{chapter 4} is about known limitations and future work, followed by \textbf{acknowledgemtents} and \textbf{refrences}.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10010147.10010371.10010382</concept_id>
<concept_desc>Computing methodologies~Image manipulation</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10010147.10010371.10010382.10010236</concept_id>
<concept_desc>Computing methodologies~Computational photography</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Image manipulation}
\ccsdesc[300]{Computing methodologies~Computational photography}

%
% End generated code
%

% The next three commands are required, and insert the user-generated keywords, 
% The CCS concepts list, and the rights management text.
% Please make sure there is a blank line between each of these three commands.

\keywordlist

\conceptlist

\printcopyright




\section{Previous Work}

Conceptually similar ideas have been expressed before, among others are:
texture-driven vertex displacement by [Norman 2015], [ratchet et al.].
It seems though that a general technique that would undergo a formal treatment and scrutiny in a form of SIGGRAPH paper is yet to be proposed.

\section{Implementation}

The proposed method includes a vertex displacement shader, driven by a texture.  The texture is a rows-columns lookup table, where every row of pixels corresponds to a key-frame and every column pixel encodes a component vector of a transofrm \(4 \times 4\) matrix. A component vector is a 3 component vector, corresponding to RGB, hence 2 vectors can be encoded as RGBRGB (6 color channels or 2 RGB pixels).  If we chose to use quaternions to store rotation, we could have used RGBA (4 channels or 1 RGBA pixel instead), thus saving 30\% of horizontal texture resolution, but implementing matrix transformation is trivial and quaternion optimization is left for future work.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.3]{images/bones_skinning.png}
  \caption{A skin mesh, m, being deformed by a skeleton consisting of bones, \(b_i\) , connected by single joints. Joint \(j_i\) is a transform belonging to bone \(b_i\) . The vertex, p, is influenced by the one or more bones \(b_i\).}
  \label{bones}
\end{figure}

A bone has two transforms; a bone space transform, \( B^{-1}_j\) , and a pose transform, \(P_j\) . Both transforms can be represented as \(4 \times 4\) homogeneous transformation matrices (figure \pageref{bones}).

\begin{equation} 
  T_j =
  \begin{pmatrix}
    T^{rot}_j & T^{trans}_j \\
    \bar 0 & 1 \\
  \end{pmatrix}
\end{equation} 

where $ T^{rot}_j$ is a $3 \times 3$ rotation matrix, $\bar 0$ is a $1 \times 3$ zero vector, and $T^{trans}_j$ is a $3 \times 1$ vector. The transform can also be represented as (quaternion, transform) pairs, which is more compact.
Since we are not trying to preserve the skeleton relationships and are only interested in the influence of a set of bones on a vertex position and normal orientation, we discard the relationships that have no influence and treat each joint orientation and position as a transfomation $4 \times 4$ matrix.  Then we perform a linear blend between a set of such transformation matrixes to get a final transformation matrix that we apply to a vertex.  The linear blend is controlled by weights.  Weights can be stored as a texture or as a secondary uv-set as proposed in [Norman]. We do that for every vertex in a vertex displacement shader, hence a vertex position can be computed as:

\begin{equation}
  P_i = \sum^n_{j=0} ((p^{rest}_i - t^{trans}_j) \cdot T^{-1}_j + t^{trans}_j) \cdot \omega_j
\end{equation}

where $P_i$ is the resulting vertex position, $p^{rest}_i$ - rest vertex position and $n$ - number of bones that influence $i^{th}$ vertex, $t^{trans}_j$ is a rest-pose translation of $j^{th}$ joint and $\omega_j$ is it's respective weight.

Naturally, a vertex normal can be computed as:

\begin{equation}
  N_i = \sum^n_{j=0} ( N^{rest}_i \cdot T^{-1}_j) \cdot \omega_j
\end{equation}

where $N_i$ - normal of $i^{th}$ vertex. As we can see, (3) and (2) are nearly identical except for translation.

We store $T_j$ and $T^{rest}_j$ as a reduced matrix (we store 2 rotation vector components and restore the 3rd as a cross product of the two).  The joints rest position and rotation is stored in the first row of pixels, hence it's deemed a technical row and is not a part of animation loop. % (Figure \ref{bones_texture}).

Vertex rest positon $p^{rest}_i$ and rest normal $N^{rest}_i$ are supplied by the rest-mesh.  Bone indices that influence each vertex correspond to horizontal pixel offset in the texture and are saved as vertex colors in the mesh (Figure \ref{mesh_vertex_colors}).  By using 4 8-bit vertex colors (RGBA), we can map up to 256 bones with 4 influences per vertex, resulting in a form of smooth-skinning, or use a single channel, resulting in hard-skinning.  In other words we store a bone number (or, equivalently, a horizontal pixel offset) as a vertex color and later read it in a shader in order to drive the horizontal offset of a texture lookup (Figure \ref{mesh_vertex_colors})

Let $\bar\theta, \bar\phi, \bar\zeta$ be the vector components of the rotation matrix $T^{rot}_j$:

\begin{equation} 
  T^{rot}_j =
  \begin{pmatrix}
    \theta_1 & \theta_2 & \theta_3 \\
    \phi_1   & \phi_2   & \phi_3 \\
    \zeta_1  & \zeta_2  & \zeta_3 \\
  \end{pmatrix}
\end{equation}

and let \textit{texture(u,v)} be a function, that, given \textit{(u,v)}, where \{$ u,v \in R, {0\leq u,v \leq 1}$\}, returns a pixel (RGB) from a texture, then, since

\begin{equation} 
  \theta =
  \begin{bmatrix}
    \theta_1 \\
    \theta_2 \\
    \theta_3
  \end{bmatrix}
  =
  \begin{bmatrix}
    R \\
    G \\
    B
  \end{bmatrix}
\end{equation}

\begin{equation}
  \begin{split}
  \theta_j & = texutre \lbrack Cd.j_i \cdot 256 \cdot n \cdot C), t\rbrack              \\
  \phi_j   & = texutre \lbrack (Cd.j_i \cdot 256 \cdot n + n) \cdot C), t\rbrack         \\
  \zeta_j  & = \theta_j \cdot \phi_j                                                    \\
  T^{trans} & = texutre \lbrack (Cd.j_i \cdot 256 \cdot n + 2 \cdot n) \cdot C), t\rbrack
  \end{split}
\end{equation}
  
where $n$ - number of bones, $t$ - animation offset (time), $Cd.j_i$ is a vertex color, $j^{th}$ component (RGBA) of a vertex $i$, multiplication by $256$ is necessary to map \{0-255\} (bone index) to \{0-1\} (8bit vertex color value), $C\in\bold{R}$ is a scalar value: since we are storing position and rotation data in a color-space of a texture, the Object Space transformation has to be scaled by a factor of $C$ in order to fit into the $\{0-1\}$ range of a color channel of a texture.
Hence the horizontal texture reolution is $n \cdot 3$, rounded to the closes power of 2, vertical resolutoin equals the number of frames (Figure \ref{bones_texture}).

\begin{figure}[ht]
  \centering
  \includegraphics[scale=3.4]{images/vda.png}
  \caption{The top-row of pixels stores joints rest rotation and position.  Columns 1 (red) and 2 (blue) encode animation of joint rotation and position (column 3).  Black area to the right is unused space. Horizontal bands in lower-half part of the texture are animation loops and poses.}
  \label{bones_texture}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.14]{images/mesh.png}
  \caption{ A rest-mesh with vertex colors encoding bone indices.}
  \label{mesh_vertex_colors}
\end{figure}

As we have mentioned before, weights can be stored in a number of ways.  We assume that the sum of weights per vertex equals 1:

\begin{equation}
  \sum^n_{j=0} \omega_j = 1
\end{equation}

Hence, in order to store 3 bone weights, we assume:

\begin{align*}  
  &\omega_1 + \omega_2 + \omega_3 = 1 \\
  &\omega_3 = 1 - (\omega_1 + \omega_2)
\end{align*}  

Therefore, we only need to store two components to deduce the third, similarly with other number of bone weights.

Because the resulting size is only $ \sqrt n $, where $ n $ is the number of vertexes, which tends to be a small number when dealing with low-res meshes, and also because it seemed like a good idea at the moment, we decided to use a secondary texture and a secondary uv-set (uv2) to store and map bone weights (Figure \ref{weights_texture}):

\begin{figure}[ht]
  \centering
  \includegraphics[scale=3.0]{images/weights.png}
  \caption{16x16 texture used to store bone wieghts}
  \label{weights_texture}
\end{figure}

By using the virtual bones texutre (Figure \ref{bones_texture}) we can build a transformation matrix that, when applied to rest-mesh vertex position and vertex normal, returns a new vertex position and normal.  By scrolling the texture lookup vertically, we can achieve animation.

\subsection{Animation switching}

Figure \ref{bones_texture} is demonstrating a number of animaion loops encoded in a single texture: a number of animation slices are visible in the lower half of the image.  In order to switch animations, the bone animation texture can store a necessary numbder of loops.  The animation lookup can be limited to a sertain texture area, thus achieving animation switching. That can be set during initialisation at spawn time of the object, or using more sophisticated logic.

\subsection{Texture generation}

The method is supporting generating the virtual bones animation texture using either existing skeleton or can convert procedural joints and other sticky objects, treating them as joints by converting their transformation data into a texture. The authors used SideFX Houdini Amimation Tools to read the Maya-exported fbx file, containing the rig and animation data, and encode the joints transformations into a texture.

\section{Results and Performance.}

The following (table \ref{performance}) contains performance cost of 1 to 100 instances of test object (base-line (BL)) and its respective 3D impostor instances (1-1200) (virtual bones (VB)). By `baseline algorithm` (BL) we understand a skeleton-based CPU-driven skinned mesh, in this specific case it's a character from HZD. Frames per second count is capped at 30 fps. BL is using the same amount of triangles (tris.) as VB.  The test is performed running a test level with a dedicated minimalistic setup, using Decima engine.

\begin{table}[h]
  \centering
  \caption{Performance comparison, whe N - number of instances, tris. - triangles count, fps - frames per second, VB - virtual bones method, BL - baseline method.}
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{N} & \multirow{2}{*}{tris.} & \multicolumn{2}{|c|}{fps}& \multicolumn{2}{|c|}{CPU time \( (\mu s) \)} & \multicolumn{2}{|c|}{GPU time \( (\%) \) }  \\ \cline{3-8}
                       &                        & BL & VB                  & BL    & VB                                    & BL    & VB                                 \\       
    \hline                                                                                                                                                   
                    1  & 4652                   & 30 & 30                  & 3168  & 0                                     & 0.317 & 0.100                              \\   
    \hline                                                                                                                                                      
                    2  & 9304                   & 30 & 30                  & 4151  & 0                                     & 0.582 & 0.192                              \\   
    \hline                                                                             
                    3  & 13956                  & 30 & 30                  & 6729  & 0                                     & 0.642 & 0.281                              \\   
    \hline                                                                             
                    4  & 18608                  & 30 & 30                  & 8554  & 0                                     & 0.704 & 0.354                              \\   
    \hline                                                                             
                    5  & 23260                  & 30 & 30                  & 9889  & 0                                     & 0.834 & 0.423                              \\   
    \hline                                                                             
                    6  & 27912                  & 30 & 30                  & 11929 & 0                                     & 1.117 & 0.501                              \\   
    \hline                      
                    7  & 32564                  & 30 & 30                  & 13098 & 0                                     & 1.141 & 0.581                              \\   
    \hline                      
                    8  & 37216                  & 30 & 30                  & 14771 & 0                                     & 1.179 & 0.645                              \\   
    \hline                      
                    9  & 41868                  & 30 & 30                  & 16689 & 0                                     & 1.267 & 0.706                              \\   
    \hline                      
                    10 & 46520                  & 30 & 30                  & 19400 & 0                                     & 1.385 & 0.756                              \\   
    \hline
                    20 & 93040                  & 30 & 30                  & 29514 & 0                                     & 2.550 & 1.449                              \\   
    \hline
                    30 & 139560                 & 30 & 30                  & 47504 & 0                                     & 3.258 & 2.170                              \\   
    \hline
                    40 & 186080                 & 24 & 30                  & 118988& 0                                     & 3.974 & 2.884                              \\   
    \hline
                    50 & 232600                 & 15 & 30                  & 153831& 0                                     & 5.083 & 3.607                              \\   
    \hline
                    60 & 279129                 & 13 & 30                  & 170660& 0                                     & 5.897 & 4.178                              \\   
    \hline
                    70 & 325640                 & 12 & 30                  & 192778& 0                                     & 6.709 & 4.609                              \\   
    \hline
                    80 & 372160                 & 10 & 30                  & 226705& 0                                     & 7.340 & 5.031                              \\   
    \hline
                    90 & 418680                 & 9  & 30                  & 254145& 0                                     & 8.513 & 5.580                              \\   
    \hline
                    100& 465200                 & 8  & 30                  & 283474& 0                                     & 9.305 & 5.987                              \\   
    \hline
                    200& 953400                 & -  & 30                  & -     & 0                                     & -     & 11.183                             \\   
    \hline
                    300& 1430100                & -  & 30                  & -     & 0                                     & -     & 13.680                             \\
    \hline
                    400& 1906800                & -  & 30                  & -     & 0                                     & -     & 17.443                             \\
    \hline
                    500& 2383500                & -  & 30                  & -     & 0                                     & -     & 21.040                             \\
    \hline
                    600& 2860200                & -  & 30                  & -     & 0                                     & -     & 24.027                             \\
    \hline
                    700& 3336900                & -  & 30                  & -     & 0                                     & -     & 26.736                             \\
    \hline
                    800& 3813600                & -  & 30                  & -     & 0                                     & -     & 29.608                             \\
    \hline
                    900& 4290300                & -  & 30                  & -     & 0                                     & -     & 32.795                             \\
    \hline
                   1000& 4767000                & -  & 30                  & -     & 0                                     & -     & 35.837                             \\
    \hline
                   1200& 5720400                & -  & 30                  & -     & 0                                     & -     & 41.459                             \\
    \hline    
  \end{tabular}
  \label{performance}
\end{table}
  
By looking at  table \ref{performance}, column 'fps' (BL), we can observe a noticable FPS drop for basline algorithm at around 30-40 instances due to CPU time cost, where it is becoming prohibitively expsnsive.  On the contrary, VB does not show any noticable frame-rate drop, due to VB zero CPU time cost (Figure \ref{framerate_drop}).

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{data/plot_00.png}
  \caption{horizontal axis: number of instances, vertical axis: frames per second. (baseline algorithm)}
  \label{framerate_drop}
\end{figure}

Looking at GPU frame time, we can see that BL curve is growing much faster, converging around \(O(n)\), while VB graph seems to converge to \(O(log (n))\). (Figures \ref{graph_growth} and \ref{graph_growth_1200})

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{data/plot_01.png}
  \caption{horizontal axis: number of instances, vertical axis: GPU frame time. BL (blue), VB(red)}
  \label{graph_growth}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.5]{data/plot_02.png}
  \caption{horizontal axis: number of instances, vertical axis: GPU frame time. BL (blue), VB(red)}
  \label{graph_growth_1200}
\end{figure}

\section{Limitations and Future Work}

Texture space waste, 64-bit uncompressed - texture size concers, compression optimization, quaternion optimization, shader initialization.

\section*{Acknowledgements}

To Marijn, for all the wisky.

\bibliographystyle{acmsiggraph}
\nocite{*}
\bibliography{template}
\end{document}

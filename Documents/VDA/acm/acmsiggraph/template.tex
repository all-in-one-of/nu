%%% template.tex
%%%
%%% This LaTeX source document can be used as the basis for your technical
%%% paper or abstract. Regardless of the length of your document, the commands
%%% are all the same.
%%% 
%%% The "\documentclass" command is the first command in your file. If you want to ere
%%% prepare a version of your article with line numbers - a "review" version - 
%%% include the "review" parameter:
%%%    \documentclass[review]{acmsi_jggraph}
%%%

\documentclass{acmsiggraph}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{mathtools}
\usepackage{graphics}
\usepackage{float}

\newcommand{\Mod}[1]{\ (\text{mod}\ #1)}
\newcommand{\tab}{{\ \ \ \ }}
\newcommand{\Deg}{{^{\circ}}}
\newcommand{\detA}{det \textbf{A}}
\newcommand{\Iff}{\scalebox{0.7}[1]{$\iff$}}
\newcommand{\Imp}{\scalebox{0.6}[1]{$\implies$}}



%%% Title of your article or abstract.

\title{Virtual Bones: animating skinned meshes on GPU}

\author{Vladimir V. Lopatin\thanks{e-mail:vladimir.lopatin82@gmail.com}\\Senior VFX Artist, Guerrilla-Games}
\pdfauthor{Vladimir V. Lopatin}

%%% Used by the ``review'' variation; the online ID will be printed on 
%%% every page of the content.

\TOGonlineid{45678}

% User-generated keywords.

\keywords{GPU, crowd-rendering, shading, skinned meshes.}

%%% The next five lines define the rights management block on the first page.
%%% Replace them with the LaTeX commands provided when the form has been completed.

% \CopyrightYear{2017}
% \setcopyright{acmcopyright}
% \conferenceinfo{CONFERENCE PROGRAM NAME}{MONTH, DAY, and YEAR} 
% \isbn{THIS-IS-A-SAMPLE-ISBN}\acmPrice{\$15.00}
% \doi{http://doi.acm.org/THIS/IS/A/SAMPLE/DOI}

%%% Start of the document.

\begin{document}

%%% This is the ``teaser'' command, which puts an figure, centered, below 
%%% the title and author information, and above the body of the content.

 \teaser{
   \includegraphics[height=1.5in]{images/vda_teaser}
   \caption{A skinned mesh character, a virtual bones texture and multiple 3D impostors.}
 }

\maketitle

\begin{abstract}
  During the production of open-world game ‘Horizon: Zero Dawn‘, we had to find a way to render large amounts of animated assets in real-time, such as crowds and locations heavily decorated with animated cloth-like assets. Analysis showed that existing assets are CPU-heavy and are resisting scaling to large numbers. Instead of using skinned meshes, driven by skeletons with complex CPU controll structures, assets had to become vastly simpler and computations had to be offset to GPU. That required creating a new pipeline that includes generating and authoring new content. We wanted to reuse existing content, so it had to be compatible with existing pipeline. We already had an implementation of [Norman], which allowed us creating assets with animationions baked into a texture that drives a vertex displacement program on GPU. However, [Norman] approach is vertex-count bound, which meant that for large meshes the animation texture size had to be large. Because our assets already had skeleton, animation and skinning data, we decided to develop a method that would do a form of skinning on GPU, but would be bound by bones, instead of vertices as in [Norman], and use existing skinning data. These challenges had to be met when programmers support time is very limited. Instead, we decided to use SideFX Houdini Animation Tools to set up a VFX pipeline to process existing assets and use existing shading programs in a version of Autodesk Maya, which did not require any extra work from programmers. This allowed us to keep animation texture size small, offset nearly all computations to GPU while keeping CPU footprint minimal or nill; we could reuse existing content, it did not require changing existing pipeline or code support from programmers, while significanly improving the visual results by allowing us to render a large amount of animated assets.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10010147.10010371.10010382</concept_id>
<concept_desc>Computing methodologies~Image manipulation</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10010147.10010371.10010382.10010236</concept_id>
<concept_desc>Computing methodologies~Computational photography</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Image manipulation}
\ccsdesc[300]{Computing methodologies~Computational photography}

%
% End generated code
%

% The next three commands are required, and insert the user-generated keywords, 
% The CCS concepts list, and the rights management text.
% Please make sure there is a blank line between each of these three commands.

\keywordlist

\conceptlist

% \printcopyright




\section{Previous Work}

Conceptually similar ideas have been expressed before, among others are:
texture-driven vertex displacement by [Norman 2015], [ratchet et al.].

We already had an implementation of [Norman], which allowed us creating assets with animations baked to a texture that drives a vertex displacement program on GPU.
However, this approach is vertex-count bound, i.e. vertex count = horizontal texture resolution; it requires additional normal transformation texture. We had to look for a method to keep the texture size small. 

\section{Implementation}

The proposed method includes a vertex displacement shader, driven by a texture.  The texture is a rows-columns lookup table, where every row of pixels corresponds to a key-frame and every column pixel encodes a component vector of a transofrm \(4 \times 4\) matrix. A component vector is a 3 component vector, corresponding to RGB, hence 2 vectors can be encoded as RGBRGB (6 color channels or 2 RGB pixels).  If we chose to use quaternions to store rotation, we could have used RGBA (4 channels or 1 RGBA pixel instead), thus saving 30\% of horizontal texture resolution, but implementing matrix transformation is trivial and quaternion optimization is left for future work.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.3]{images/bones_skinning.png}
  \caption{A skin mesh, m, being deformed by a skeleton consisting of bones, \(b_i\) , connected by single joints. Joint \(j_i\) is a transform belonging to bone \(b_i\) . The vertex, p, is influenced by the one or more bones \(b_i\).}
  \label{bones}
\end{figure}

A bone has two transforms; a bone space transform, \( B^{-1}_j\) , and a pose transform, \(P_j\) . Both transforms can be represented as \(4 \times 4\) homogeneous transformation matrices (figure \pageref{bones}).

\begin{equation} 
  T_j =
  \begin{pmatrix}
    T^{rot}_j & T^{trans}_j \\
    \bar 0 & 1 \\
  \end{pmatrix}
\end{equation} 

where $ T^{rot}_j$ is a $3 \times 3$ rotation matrix, $\bar 0$ is a $1 \times 3$ zero vector, and $T^{trans}_j$ is a $3 \times 1$ vector. The transform can also be represented as (quaternion, transform) pairs, which is more compact.
Since we are not trying to preserve the skeleton relationships and are only interested in the influence of a set of bones on a vertex position and normal orientation, we discard the relationships that have no influence and treat each joint orientation and position as a transfomation $4 \times 4$ matrix.  Then we perform a linear blend between a set of such transformation matrixes to get a final transformation matrix that we apply to a vertex.  The linear blend is controlled by weights.  Weights can be stored as a texture or as a secondary uv-set as proposed in [Norman]. We do that for every vertex in a vertex displacement shader, hence a vertex position can be computed as:

\begin{equation}
  \bar{P}_i = \sum^n_{j=0} ((\bar{p}^{rest}_i - \bar{t}^{trans}_j) \cdot T^{-1}_j + \bar{t}^{trans}_j) \cdot \omega_j
\end{equation}

where $\bar{P}_i$ is the resulting vertex position, $\bar{p}^{rest}_i$ - rest vertex position and $n$ - number of bones that influence $i^{th}$ vertex, $\bar{t}^{trans}_j$ is a rest-pose translation of $j^{th}$ joint and $\omega_j$ is it's respective weight.

\begin{equation}
  \bar{N}_i = \sum^n_{j=0} ( \bar{N}^{rest}_i \cdot T^{-1}_j) \cdot \omega_j
\end{equation}

where $\bar{N}_i$ - normal of $i^{th}$ vertex. As we can see, (3) and (2) are nearly identical except for translation.

We store $T_j$ and $T^{rest}_j$ as a reduced matrix (we store 2 rotation vector components and restore the 3rd as a cross product of the two).  The joints rest position and rotation is stored in the first row of pixels, hence it's deemed a technical row and is not a part of animation loop. % (Figure \ref{bones_texture}).

Vertex rest positon $\bar{p}^{rest}_i$ and rest normal $\bar{N}^{rest}_i$ are supplied by the rest-mesh.  Bone indices that influence each vertex correspond to horizontal pixel offset in the texture and are saved as vertex colors in the mesh (Figure \ref{mesh_vertex_colors}).  By using 4 8-bit vertex colors (RGBA), we can map up to 256 bones with 4 influences per vertex, resulting in a form of smooth-skinning, or use a single channel, resulting in hard-skinning.  In other words we store a bone number (or, equivalently, a horizontal pixel offset) as a vertex color and later read it in a shader in order to drive the horizontal offset of a texture lookup (Figure \ref{mesh_vertex_colors})

Let $\bar\theta, \bar\phi, \bar\zeta$ be the vector components of the rotation matrix $T^{rot}_j$:

\begin{equation} 
  [T^{rot}_j]^{T} =
  \begin{pmatrix}
    \theta_1 & \theta_2 & \theta_3 \\
    \phi_1   & \phi_2   & \phi_3 \\
    \zeta_1  & \zeta_2  & \zeta_3 \\
  \end{pmatrix}
\end{equation}

and let \textit{texture(u,v)} be a function, that, given \textit{(u,v)}, where \{$ u,v \in \textbf{R}; u,v \in \{0,1\}$\}, returns a pixel (RGB) from a texture, then, since

\begin{equation} 
  \theta =
  \begin{bmatrix}
    \theta_1 \\
    \theta_2 \\
    \theta_3
  \end{bmatrix}
  =
  \begin{bmatrix}
    R \\
    G \\
    B
  \end{bmatrix}
\end{equation}

\begin{equation}
  \begin{split}
  \theta_j & = texutre \lbrack Cd.j_i \cdot 256 \cdot n \cdot C), t\rbrack              \\
  \phi_j   & = texutre \lbrack (Cd.j_i \cdot 256 \cdot n + n) \cdot C), t\rbrack         \\
  \zeta_j  & = \theta_j \cdot \phi_j                                                    \\
  T^{trans} & = texutre \lbrack (Cd.j_i \cdot 256 \cdot n + 2 \cdot n) \cdot C), t\rbrack
  \end{split}
\end{equation}
  
where $n$ - number of bones, $t \in \textbf{R}$ - animation offset (time), $Cd.j_i$ is a vertex color, $j^{th}$ component (RGBA) of a vertex $i$, multiplication by $256$ is necessary to map \{0-255\} (bone index) to \{0-1\} (8bit vertex color value), $C\in\bold{R}$ is a scalar space-normalisation constant

The resulting horizontal texture resolution is $n \cdot 3$, rounded to the closes power of 2, vertical resolutoin equals the number of frames (Figure \ref{bones_texture}).

\begin{figure}[ht]
  \centering
  \includegraphics[scale=3.4]{images/vda.png}
  \caption{The top-row of pixels stores joints rest rotation and position.  Columns 1 (red) and 2 (blue) encode animation of joint rotation and position (column 3).  Black area to the right is unused space. Horizontal bands in lower-half part of the texture are animation loops and poses.}
  \label{bones_texture}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.14]{images/mesh.png}
  \caption{ A rest-mesh with vertex colors encoding bone indices.}
  \label{mesh_vertex_colors}
\end{figure}

As we have mentioned before, weights can be stored in a number of ways.  We assume that the sum of weights per vertex equals 1:

\begin{equation}
  \sum^n_{j=0} \omega_j = 1
\end{equation}

Hence, in order to store 3 bone weights, we assume:

\begin{align*}  
  &\omega_1 + \omega_2 + \omega_3 = 1 \\
  &\omega_3 = 1 - (\omega_1 + \omega_2)
\end{align*}  

Therefore, we only need to store two components to deduce the third, similarly with other number of bone weights.

Because the resulting size is only $ \sqrt n $, where $ n $ is the number of vertexes, which tends to be a small number when dealing with low-res meshes, and also because it seemed like a good idea at the moment, we decided to use a secondary texture and a secondary uv-set (uv2) to store and map bone weights (Figure \ref{weights_texture}):

\begin{figure}[ht]
  \centering
  \includegraphics[scale=3.0]{images/weights.png}
  \caption{16x16 texture used to store bone wieghts}
  \label{weights_texture}
\end{figure}

By using the virtual bones texutre (Figure \ref{bones_texture}) we can build a transformation matrix that, when applied to rest-mesh vertex position and vertex normal, returns a new vertex position and normal.  By scrolling the texture lookup vertically, we can achieve animation.

\subsection{Animation switching}

Figure \ref{bones_texture} is demonstrating a number of animaion loops encoded in a single texture: a number of animation slices are visible in the lower half of the image.  In order to switch animations, the bone animation texture can store a necessary numbder of loops.  The animation lookup can be limited to a sertain texture area, thus achieving animation switching. That can be set during initialisation at spawn time of the object, or using more sophisticated logic.

\subsection{Texture generation}

The method is supporting generating the virtual bones animation texture using either existing skeleton or can convert procedural joints and other sticky objects, treating them as joints by converting their transformation data into a texture. The authors used SideFX Houdini Amimation Tools to read the Maya-exported fbx file, containing the rig and animation data, and encode the joints transformations into a texture.

\section{Results and Performance.}

The following (table \ref{performance}) contains performance cost of 1 to 100 instances of test object (base-line (BL)) and its respective 3D impostor instances (1-1200) (virtual bones (VB)). By `baseline algorithm` (BL) we understand a skeleton-based CPU-driven skinned mesh, in this specific case it's a character from HZD. Frames per second count is capped at 30 fps. BL is using the same amount of triangles (tris.) as VB.  The test is performed running a test level with a dedicated minimalistic setup, using Decima engine.

\begin{table}[h]
  \centering
  \caption{Performance comparison, whe N - number of instances, tris. - triangles count, fps - frames per second, VB - virtual bones method, BL - baseline method.}
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{N} & \multirow{2}{*}{tris.} & \multicolumn{2}{|c|}{fps}& \multicolumn{2}{|c|}{CPU time \( (\mu s) \)} & \multicolumn{2}{|c|}{GPU time \( (\%) \) }  \\ \cline{3-8}
                       &                        & BL & VB                  & BL    & VB                                    & BL    & VB                                 \\       
    \hline                                                                                                                                                   
                    1  & 4652                   & 30 & 30                  & 3168  & 0                                     & 0.317 & 0.100                              \\   
    \hline                                                                                                                                                      
                    2  & 9304                   & 30 & 30                  & 4151  & 0                                     & 0.582 & 0.192                              \\   
    \hline                                                                             
                    3  & 13956                  & 30 & 30                  & 6729  & 0                                     & 0.642 & 0.281                              \\   
    \hline                                                                             
                    4  & 18608                  & 30 & 30                  & 8554  & 0                                     & 0.704 & 0.354                              \\   
    \hline                                                                             
                    5  & 23260                  & 30 & 30                  & 9889  & 0                                     & 0.834 & 0.423                              \\   
    \hline                                                                             
                    6  & 27912                  & 30 & 30                  & 11929 & 0                                     & 1.117 & 0.501                              \\   
    \hline                      
                    7  & 32564                  & 30 & 30                  & 13098 & 0                                     & 1.141 & 0.581                              \\   
    \hline                      
                    8  & 37216                  & 30 & 30                  & 14771 & 0                                     & 1.179 & 0.645                              \\   
    \hline                      
                    9  & 41868                  & 30 & 30                  & 16689 & 0                                     & 1.267 & 0.706                              \\   
    \hline                      
                    10 & 46520                  & 30 & 30                  & 19400 & 0                                     & 1.385 & 0.756                              \\   
    \hline
                    20 & 93040                  & 30 & 30                  & 29514 & 0                                     & 2.550 & 1.449                              \\   
    \hline
                    30 & 139560                 & 30 & 30                  & 47504 & 0                                     & 3.258 & 2.170                              \\   
    \hline
                    40 & 186080                 & 24 & 30                  & 118988& 0                                     & 3.974 & 2.884                              \\   
    \hline
                    50 & 232600                 & 15 & 30                  & 153831& 0                                     & 5.083 & 3.607                              \\   
    \hline
                    60 & 279129                 & 13 & 30                  & 170660& 0                                     & 5.897 & 4.178                              \\   
    \hline
                    70 & 325640                 & 12 & 30                  & 192778& 0                                     & 6.709 & 4.609                              \\   
    \hline
                    80 & 372160                 & 10 & 30                  & 226705& 0                                     & 7.340 & 5.031                              \\   
    \hline
                    90 & 418680                 & 9  & 30                  & 254145& 0                                     & 8.513 & 5.580                              \\   
    \hline
                    100& 465200                 & 8  & 30                  & 283474& 0                                     & 9.305 & 5.987                              \\   
    \hline
                    200& 953400                 & -  & 30                  & -     & 0                                     & -     & 11.183                             \\   
    \hline
                    300& 1430100                & -  & 30                  & -     & 0                                     & -     & 13.680                             \\
    \hline
                    400& 1906800                & -  & 30                  & -     & 0                                     & -     & 17.443                             \\
    \hline
                    500& 2383500                & -  & 30                  & -     & 0                                     & -     & 21.040                             \\
    \hline
                    600& 2860200                & -  & 30                  & -     & 0                                     & -     & 24.027                             \\
    \hline
                    700& 3336900                & -  & 30                  & -     & 0                                     & -     & 26.736                             \\
    \hline
                    800& 3813600                & -  & 30                  & -     & 0                                     & -     & 29.608                             \\
    \hline
                    900& 4290300                & -  & 30                  & -     & 0                                     & -     & 32.795                             \\
    \hline
                   1000& 4767000                & -  & 30                  & -     & 0                                     & -     & 35.837                             \\
    \hline
                   1200& 5720400                & -  & 30                  & -     & 0                                     & -     & 41.459                             \\
    \hline    
  \end{tabular}
  \label{performance}
\end{table}
  
By looking at  table \ref{performance}, column 'fps' (BL), we can observe a noticable FPS drop for basline algorithm at around 30-40 instances due to CPU time cost, where it is becoming prohibitively expsnsive.  On the contrary, VB does not show any noticable frame-rate drop, due to VB zero CPU time cost (Figure \ref{framerate_drop}).

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{data/plot_00.png}
  \caption{horizontal axis: number of instances, vertical axis: frames per second. (baseline algorithm)}
  \label{framerate_drop}
\end{figure}

Looking at GPU frame time, we can see that BL curve is growing much faster, converging around \(O(n)\), while VB graph seems to converge to \(O(log (n))\). (Figures \ref{graph_growth} and \ref{graph_growth_1200})

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{data/plot_01.png}
  \caption{horizontal axis: number of instances, vertical axis: GPU frame time. BL (blue), VB(red)}
  \label{graph_growth}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.5]{data/plot_02.png}
  \caption{horizontal axis: number of instances, vertical axis: GPU frame time. BL (blue), VB(red)}
  \label{graph_growth_1200}
\end{figure}

\section{Limitations and Future Work}

Because the horizonral texture resolution was rounded to the closest power of 2, that led to some texture space waste.  We used transformation matrices, instead of quaternions - using quaternions would allow further reducing texture size.  In order to minimize rounding errors, the animation texture had to be stored as 32bit uncompressed. Storing rotation and translation components in 2 separate textures may improve packing and reduce space waste. More research is required in regards to losless compression of animation texture.

\section*{Acknowledgements}

To Marijn, for all the wisky.

\bibliographystyle{acmsiggraph}
\nocite{*}
\bibliography{template}
\end{document}
